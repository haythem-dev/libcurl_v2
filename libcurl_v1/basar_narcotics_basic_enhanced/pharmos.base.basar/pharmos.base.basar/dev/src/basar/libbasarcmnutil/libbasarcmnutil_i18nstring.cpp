//----------------------------------------------------------------------------
/*! \file
 *  \brief  class implementation of international string
 *  \author Thomas Hörath
 *  \date   04.10.2005
 */
//----------------------------------------------------------------------------

#include "libbasarcmnutil_i18nstring.h"

#include "libbasarcmnutil_locale.h"

#include <assert.h>
#include <sstream>
#include <iomanip>
#include <stdlib.h>

//----------------------------------------------------------------------------
namespace basar {
namespace cmnutil{

//----------------------------------------------------------------------------
/*! \ingroup DIFF_WIN_UNIX */ 
#ifdef _WIN32

//! upper/lower table for conversion for codepage West: 0xA0 - 0xFF
static const unsigned char CONV_EXT_WEST[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x8a, 0x9b, 0x8c, 0x9d, 0x8e, 0x9f, 
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0x9f 
    },
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x9a, 0x8b, 0x9c, 0x8d, 0x9e, 0x8f, 
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xff, 
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

//! upper/lower table for conversion for codepage East: 0xA0 - 0xFF
static const unsigned char CONV_EXT_EAST[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x8a, 0x9b, 0x8c, 0x8d, 0x8e, 0x8f, 
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 
        0xb0, 0xb1, 0xb2, 0xa3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xa5, 0xaa, 0xbb, 0xbc, 0xbd, 0xbc, 0xaf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff 
    },
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x9a, 0x8b, 0x9c, 0x9d, 0x9e, 0x9f, 
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 
        0xa0, 0xa1, 0xa2, 0xb3, 0xa4, 0xb9, 0xa6, 0xa7, 0xa8, 0xa9, 0xba, 0xab, 0xac, 0xad, 0xae, 0xbf, 
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbe, 0xbd, 0xbe, 0xbf, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

//! upper/lower table for conversion for codepage West: 0xA0 - 0xFF
static const unsigned char CONV_EXT_CYRILLIC[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x81, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 
        0x80, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x8a, 0x9b, 0x8c, 0x8d, 0x8e, 0x8f, 
        0xa0, 0xa1, 0xa1, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 
        0xb0, 0xb1, 0xb2, 0xb2, 0xa5, 0xb5, 0xb6, 0xb7, 0xa8, 0xb9, 0xaa, 0xbb, 0xa3, 0xbd, 0xbd, 0xaf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf
    },
    {
        0x90, 0x83, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x9a, 0x8b, 0x9c, 0x9d, 0x9e, 0x9f, 
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 
        0xa0, 0xa2, 0xa2, 0xbc, 0xa4, 0xb4, 0xa6, 0xa7, 0xb8, 0xa9, 0xba, 0xab, 0xac, 0xad, 0xae, 0xbf, 
        0xb0, 0xb1, 0xb3, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbe, 0xbe, 0xbf, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

#else

//! upper/lower table for conversion for codepage West: 0xA0 - 0xFF
static const unsigned char CONV_EXT_WEST[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff        
    },
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

//! upper/lower table for conversion for codepage East: 0xA0 - 0xFF
static const unsigned char CONV_EXT_EAST[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xa1, 0xb2, 0xa3, 0xb4, 0xa5, 0xa6, 0xb7, 0xb8, 0xa9, 0xaa, 0xab, 0xac, 0xbd, 0xae, 0xaf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff
    },
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xb1, 0xa2, 0xb3, 0xa4, 0xb5, 0xb6, 0xa7, 0xa8, 0xb9, 0xba, 0xbb, 0xbc, 0xad, 0xbe, 0xbf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

//! upper/lower table for conversion for codepage West: 0xA0 - 0xFF
static const unsigned char CONV_EXT_CYRILLIC[][128] = 
{
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xf0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xfd, 0xae, 0xaf        
    },
    {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xad, 0xfe, 0xff,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
    }
};

#endif

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString()
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const value_type ch ) : BString(ch)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const value_type * pStr ) : BString(pStr)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const CharString & rStr ) : BString(rStr)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const BString & rStr ) : BString(rStr)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const I18nString & rStr ) : BString(rStr)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString ( const BString   & rStr,
						 const size_type   off,
						 const size_type   count ) : BString(rStr, off, count)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString	( const I18nString & rStr,
						  const size_type	 off,
						  const size_type	 count ) : BString(rStr, off, count)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
I18nString::I18nString	( const_iterator     first,
						  const_iterator     last ) : BString(first, last)
{
}

//----------------------------------------------------------------------------
/*!	\throw no-throw 
    virtual destructor */
I18nString::~I18nString()
{
}

//----------------------------------------------------------------------------
/*!	\return string converted to double; depends on Locale */
Float64 I18nString::stof () const
{
 	BString str(*this);

    str.remove  (Locale::getDec1000thSep());
	str.exchange(Locale::getDecSep(), Locale::getDecSep(Locale::C));

    return str.stof();
}

//----------------------------------------------------------------------------
/*!	\return double converted to string; depends on Locale */
void I18nString::ftos( Float64 number, Int32 precision /*= 6*/ )
{
	BString::ftos(number, precision);

	exchange          (Locale::getDecSep(Locale::C), Locale::getDecSep());
    erase1000sSep     (*this);
    eraseTrailingZeros(*this);
}

//----------------------------------------------------------------------------
void I18nString::convert(const bool up)
{
    if ( empty() )
        return;

    const unsigned char * pConv;
    const size_t          idx = up ? 0 : 1;

    switch (Locale::getRegularCodepage())
    {
    case Locale::CP_CYRILLIC:
        pConv = CONV_EXT_CYRILLIC[idx];
        break;

    case Locale::CP_EAST:
        pConv = CONV_EXT_EAST[idx];
        break;

    case Locale::CP_WEST:
    default:
        if (Locale::C == Locale::getLocale())
        {
            up ? BString::upper() : BString::lower();
            return;
        }

        pConv = CONV_EXT_WEST[idx];
        break;
    }

    iterator       itCur = begin();
	const_iterator itEnd = end  ();
    unsigned char  in;
    int            out;

    while( itCur != itEnd )
    {
        in = static_cast<unsigned char>(*itCur);

        // ASCII
        if (in < 0x80)
            out = up ? ::toupper(in) : ::tolower(in);
        else
            out = pConv[in - 0x80]; // array starts with offset 0xA0

        *itCur = static_cast<value_type>(out);

		++itCur;           
    }
}

//----------------------------------------------------------------------------
void I18nString::lower()
{
    const bool up = false;
    convert(up);
}

const I18nString I18nString::toLower() const
{
    I18nString tmp(*this);

    tmp.lower();

    return tmp;
}

//----------------------------------------------------------------------------
void I18nString::upper()
{
    const bool up = true;
    convert(up);
}

//----------------------------------------------------------------------------
const I18nString I18nString::toUpper() const
{
    I18nString tmp(*this);

    tmp.upper();

    return tmp;
}

//----------------------------------------------------------------------------
/*!	\throw no-throw  */
void I18nString::cleanchar()
{
    if ( empty() )
        return;

    iterator       itCur = begin();
	const_iterator itEnd = end  ();

	// check for printable character including space (0x20 – 0x7E)
    while( itCur != itEnd )
    {
        if ( ! isprintable(*itCur) )
        {
			*itCur = 0x20;		// set to space
        }

        ++itCur;        
    }
}

//----------------------------------------------------------------------------
void I18nString::appFmtFlags(const value_type * & src, 
                             BString            & dest)
{
    for (; *src != '\0'; ++src)
    {
        switch (*src)
        {
        case '-':
        case '+':
        case ' ':
        case '#':
        case '0':
            dest.append(1, *src);
            break;

        default:
            return;
        }
    }
}

//----------------------------------------------------------------------------
void I18nString::appFmtLength(const value_type * & src, 
                              BString            & dest,
                              va_list            & argList)
{
    BString tmp;

    for (bool digit = false; *src != '\0'; ++src)
    {
        if (::isdigit(static_cast<UInt8>(*src)))
        {
            dest.append(1, *src);
            digit = true;
        }
        else if ('*' == *src)
        {
            if (!digit)
            {
                tmp.itos(va_arg(argList, int));
                dest.append(tmp);

                ++src;
            }
            
            return;
        }
        else
            return;
    }
}

//----------------------------------------------------------------------------
void I18nString::appFmtPrec(const value_type * & src, 
                            BString            & dest,
                            va_list            & argList)
{
    if ('.' != *src)
        return;

    dest.append(1, *src);
    ++src;

    appFmtLength(src, dest, argList);
}

//----------------------------------------------------------------------------
void I18nString::appFmtSubspec(const value_type * & src, 
                               BString            & dest)
{
    bool found = false;

    do
    {
        switch (*src)
        {
        case 'h':
        case 'l':
        case 'L':
            dest.append(1, *src);
            ++src;
            found = true;
            break;

        default:
            found = false;
            break;
        }
    }while(found);
}

//----------------------------------------------------------------------------
void I18nString::appFmtTypespec(const value_type * src, 
                                BString          & dest)
{
    switch (*src)
    {
    case 's':
    case 'c':
	case 'd':
	case 'i':
	case 'u':
	case 'x':
	case 'X':
	case 'o':
	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
	case 'p':
	case 'n':
        dest.append(1, *src);
		break;

    default:
        assert(false);  // unknown type
    }
}

//----------------------------------------------------------------------------
void I18nString::appFmtValue(BString    & src,
                             va_list    & argList)
{
    // src contains at least 1 char
    const value_type type = *(src.end() - 1);

    BString save;
    swap(save);

    switch (type)
    {
    case 's':
        BString::formatV(src.c_str(), argList);
        va_arg(argList, value_type *);
        break;

    case 'c':
	case 'd':
	case 'i':
	case 'u':
	case 'x':
	case 'X':
	case 'o':
        BString::formatV(src.c_str(), argList);
		va_arg(argList, size_type);
		break;

	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
        BString::formatV(src.c_str(), argList);
		va_arg(argList, Float64);
        exchange(Locale::getDecSep(Locale::C), Locale::getDecSep());
		break;

	case 'p':
        BString::formatV(src.c_str(), argList);
		va_arg(argList, void *);
		break;

	case 'n':
        save.exchange('%', "%%");
        save.append(src);

        BString::formatV(save.c_str(), argList);  // number of chars stored in argList parameter
        save.clear();                             // %n: nothing printed
		va_arg(argList, size_type *);
		break;

    default:
        return;
    }

    swap(save);
    append(save);
}

//----------------------------------------------------------------------------
/*!	\throw no-throw */
void I18nString::formatV(const value_type * pFormat, va_list argList)
{
    if ( !pFormat || ('\0' == *pFormat) )
	    return;

    clear();

    for (const value_type * token = pFormat; *token != '\0'; ++token)
    {
        // as long as no formating sequence is found, copy chars to string
        // consume additional '%' if preceeding '%' is found: "%%" -> "%"
        if ( (*token != '%') || (*(++token) == '%') )
        {
            append(1, *token);
            continue;
        }

        // hold format for every argument
        BString fmt = "%";
        
        appFmtFlags   (token, fmt);
        appFmtLength  (token, fmt, argList);
        appFmtPrec    (token, fmt, argList);
        appFmtSubspec (token, fmt);
        appFmtTypespec(token, fmt);
        appFmtValue   (fmt  , argList);
    }
}

//----------------------------------------------------------------------------
void I18nString::erase1000sSep(VarString & str)
{
    VarString thousandsSep = Locale::getDec1000thSep();

    // for locales w/o thousands sep
    if ("0" == thousandsSep)
        return;

    str.remove(thousandsSep);
}

//----------------------------------------------------------------------------
//! \return bool indicating charater is printable (= true) in current locale 
bool I18nString::isprintable(value_type character)
{
    unsigned char uchar = static_cast<unsigned char>(character);

    switch(Locale::getLocale())
    {
	case Locale::ENGLISH_GB:
	case Locale::ENGLISH_US:
	case Locale::FRENCH_CH:
	case Locale::FRENCH_FR:
	case Locale::GERMAN_DE:
	case Locale::GERMAN_AT:
	case Locale::GERMAN_CH:
    case Locale::CROATIAN_HR:
	case Locale::BOSNIAN_BA:
	case Locale::SERBIAN_RS:
	case Locale::CZECH_CZ:
    case Locale::BULGARIAN_BG:
        //uses ISO/IEC_8859-1 printable characters, see http://en.wikipedia.org/wiki/ISO/IEC_8859-1
        //uses ISO/IEC 8859-2 printable characters, see http://en.wikipedia.org/wiki/ISO/IEC_8859-2
        //uses ISO/IEC 8859-5 printable characters, see http://en.wikipedia.org/wiki/ISO/IEC_8859-5
        return ( ((uchar >= 0x20) && (uchar <= 0x7E)) || (uchar >= 0xA0)    );

    case Locale::C:
    default:
        return (uchar >= 0x20 && uchar <= 0x7E);
    }
}

//----------------------------------------------------------------------------
}//cmnutil
}//basar
