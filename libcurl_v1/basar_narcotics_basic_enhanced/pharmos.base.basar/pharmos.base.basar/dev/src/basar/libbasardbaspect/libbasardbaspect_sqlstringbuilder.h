	#ifndef GUARD_LIBBASARSQLSTRINGBUILDER_H
#define GUARD_LIBBASARSQLSTRINGBUILDER_H
//----------------------------------------------------------------------------
/*! \file
 *  \brief  public interface for building SQL - statements
 *  \author Roland Kiefert
 *  \date   14.07.2005
 */
//----------------------------------------------------------------------------

#ifndef LIBBASARDBASPECT_API
	#ifdef _WIN32
		#ifdef LIBBASARDBASPECT_EXPORTS
			#define LIBBASARDBASPECT_API __declspec(dllexport)	//!< dll exported
		#else
		    #define LIBBASARDBASPECT_API __declspec(dllimport)	//!< dll imported
	    #endif 
	#else 
		#define LIBBASARDBASPECT_API
	#endif 
#endif

/*--------------------------------------------------------------------------------------------------*/
#include "libbasardbaspect_definitions.h"

/*--------------------------------------------------------------------------------------------------*/
namespace basar
{
    namespace db
    {
        namespace aspect
        {
            class ISQLStringBuilderImpl;
        }
    }
    namespace property
    {
        class PropertyType;
    }
}


namespace basar {
namespace db {
namespace aspect {

/*--------------------------------------------------------------------------------------------------*/
class AccessMethod;
class SQLStringBuilderImpl;
class AccessorPropertyTable_YIterator;

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class to build SQL - statements.

  From this class the programmer must derive his own class (mySQLBuilder).
  He has to overwrite the functions isQuery(), isExecutable() and
  buildSQLString(). Also he has to write the function create() in the
  following way: 
  "boost::shared_ptr<SQLStringBuilder> create() { return boost::shared_ptr<SQLStringBuilder>(new mySQLBuilder(*this)); }"
  This is a value class, copying is allowed, generated by the compiler */
class SQLStringBuilder
{
public:
    enum StringbuilderType
    {
        STRINGBUILDER,
        PREPARED_STRINGBUILDER
    };

public:
	/*! \brief This destructor supports inheritance. 
		\n	   no-throw */
	LIBBASARDBASPECT_API virtual ~SQLStringBuilder();
	/*! \brief This constructor creates a smart-pointer to the class SQLStringBuilderImpl
	    \param type indicating type of SQLStringBuilder (prepared or normal stringbuilder)
		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilder(StringbuilderType type = STRINGBUILDER);
	/*! \brief The method returns true, if the statement is a query. Must be overwritten. 
 		\n     no-throw */
	LIBBASARDBASPECT_API virtual std::pair<bool, QueryTypeEnum> isQuery() const = 0;
	
	/*! \brief The method returns a prepared statemnts IndexTypeCollection containing type of property and the indexes of the property in yit and prepared statement  */
	LIBBASARDBASPECT_API const IndexTypeCollection& getPreparedParameterTypePositionCollection() const;

	/*! \brief The method returns true, if the statement is a prepared statement. Must be overwritten. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API virtual bool isPrepareable() const = 0;
	
	/*! \brief The method builds the statement, if the class is executable 
		\n     UnknownPropertyNameException */
	LIBBASARDBASPECT_API bool	 build(const AccessorPropertyTable_YIterator& propertyList);
	/*! \brief The method returns the statement. 
		\n     no-throw */
	LIBBASARDBASPECT_API const VarString&						getSQLString() const;
	/*! \brief The method returns the propertyList / y-Iterator to an AccessorPropertyTable. 
		\n     no-throw */
	LIBBASARDBASPECT_API const AccessorPropertyTable_YIterator	getPropertyList() const;
	/*! \brief The method sets default parameters for all sql-statements of this builder 
		\n no-throw */
	LIBBASARDBASPECT_API void									setParameterList( const basar::cmnutil::ParameterList paramList );
		 
	 /*! \brief get default parameters for all sql-statements of this builder \n no-throw */
	LIBBASARDBASPECT_API basar::cmnutil::ParameterList          getParameterList() const;

	/*! \brief The method creates this class SQLStringBuilder itself. Must be overwritten. 
		\n     no-throw */
	LIBBASARDBASPECT_API virtual const boost::shared_ptr<SQLStringBuilder> create() const = 0;

protected:
	/*! \brief The method returns true, if the statement of this class is executable. Must be overwritten. 
		\n     no-throw */
	LIBBASARDBASPECT_API virtual bool isExecutable() const = 0;
	
	/*! \brief The method returns true, if all given properties are set, 
               so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSet( 
        const PropertyName& rPropertyNames  //!< Propertynames as String
        ) const;

	/*! \brief The method returns true, if all given properties are set, 
        so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool	arePropertiesSet(
        const basar::cmnutil::ParameterList& rParaList //!< Propertynames as ParameterList
        ) const;

	/*! \brief The method returns true, if all given properties are set 
               and at least one of the given properties 
			   is in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndOneMustBeInState(
        const PropertyName& rPropertyNames,  //!< Propertynames as String
	    const PropertyStateSet& rState       //!< PropertyState as PropertyStateSet
        ) const;
	
       /*! \brief return true, if all given properties are set and at 
                least one of the given properties 
				is in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndOneMustBeInState(
        const basar::cmnutil::ParameterList& rPropertyNames, //!< Propertynames as ParameterList
		const PropertyStateSet& rState                       //!< PropertyState as PropertyStateSet
        ) const;
	

	/*! \brief The method returns true, if all given properties are set 
               and at least one of the given properties 
			   is in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndOneMustBeInState(
        const PropertyName& rPropertyNames, //!< Propertynames as String
		const VarString& rState             //!< PropertyState as String
        ) const;

    /*! \brief The method returns true, if all given properties are set 
               and at least one of the given properties 
			   is in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndOneMustBeInState(
        const basar::cmnutil::ParameterList& rPropertyNames,  //!< Propertynames as ParameterList
		const VarString& rState                               //!< PropertyState as String
        ) const;
	
	/*! \brief The method returns true, if all given properties are set 
               and all of the given properties 
			   are in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndAllInState( 
        const PropertyName& rPropertyNames, //!< Propertynames as String
        const PropertyStateSet& rState      //!< PropertyState as PropertyStateSet
        ) const;

	/*! \brief The method returns true, if all given properties are set and at all 
               of the given properties 
			   are in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndAllInState( 
        const PropertyName& rPropertyNames, //!< Propertynames as String
		const VarString& rState             //!< PropertyState as String
        ) const;

    	/*! \brief The method returns true, if all given properties 
                   are set and all of the given properties 
				   are in one of the given states, so that sqlstring is executable 
		    \n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndAllInState( 
        const basar::cmnutil::ParameterList& rPropertyNames, //!< Propertynames as ParameterList
		const PropertyStateSet& rState                       //!< PropertyState as PropertyStateSet
        ) const;

    	/*! \brief The method returns true, if all given properties are set 
                and all of the given properties 
				are in one of the given states, so that sqlstring is executable 
		\n     no-throw */
	LIBBASARDBASPECT_API bool arePropertiesSetAndAllInState( 
        const basar::cmnutil::ParameterList& rPropertyNames, //!< Propertynames as ParameterList
        const VarString& rState                              //!< PropertyState as String
        ) const;

	/*! \brief	The method returns true, if all given properties (1st parameter) 
                 are set and at least one of the given properties
				(2nd parameter) is in one of the given states, 
                so that sqlstring is executable. 
                \n no-throw */
	LIBBASARDBASPECT_API bool are1stPropertiesSetAnd2ndOneInState(  
        const basar::cmnutil::ParameterList& plShouldBeSet,         //!< Properties that have to be set
		const basar::cmnutil::ParameterList& plOneMustBeInState,    //!< Properties where one has to be in state
		const PropertyStateSet& pss                                 //!< PropertyState one second property has to be in
        ) const;

    /*! \brief	The method returns true, if all given properties (1st parameter) 
                 are set and at least one of the given properties
				(2nd parameter) is in one of the given states, 
                so that sqlstring is executable. 
                \n no-throw */
    LIBBASARDBASPECT_API bool are1stPropertiesSetAnd2ndOneInState( 
        const basar::cmnutil::ParameterList& plShouldBeSet,        //!< Properties that have to be set
		const basar::cmnutil::ParameterList& plOneMustBeInState,   //!< Properties where one has to be in state
		const VarString& pss                                       //!< PropertyState one second property has to be in
        ) const;

	/*! \brief	The method returns true, if all given properties (1st parameter) 
                 are set and at least one of the given properties
				(2nd parameter) is in one of the given states, 
                so that sqlstring is executable. 
                \n no-throw */
    LIBBASARDBASPECT_API bool are1stPropertiesSetAnd2ndOneInState(	
        const PropertyName& propertyNamesShouldBeSet,             //!< Properties that have to be set
		const PropertyName& propertyNamesOneMustBeInState,        //!< Properties where one has to be in state
		const PropertyStateSet& pss                               //!< PropertyState one second property has to be in
        ) const;
	
	/*! \brief	The method returns true, if all given properties (1st parameter) 
                 are set and at least one of the given properties
				(2nd parameter) is in one of the given states, 
                so that sqlstring is executable. 
                \n no-throw */
    LIBBASARDBASPECT_API bool are1stPropertiesSetAnd2ndOneInState(	
        const PropertyName& propertyNamesShouldBeSet,        //!< Properties that have to be set
		const PropertyName& propertyNamesOneMustBeInState,   //!< Properties where one has to be in state
		const VarString& rState                              //!< PropertyState one second property has to be in
        ) const;

	/*! \brief	The method returns true, if given property is not in 
                unset state and yiterator is not at the end 
		        \n no-throw */
	LIBBASARDBASPECT_API bool	isNotEndAndSet( const PropertyName& rPropertyName ) const;
	
	/*! \brief	The method returns true, if yiterator 
                contains given property and property is not in unset state 
		        \n no-throw */
	LIBBASARDBASPECT_API bool	isContainedAndSet( const PropertyName& rPropertyName ) const;


	/*! \brief The method builds the SQL-statement. Must be overwritten. 
		\n     UnknownPropertyNameException */
	LIBBASARDBASPECT_API virtual void		buildSQLString	() = 0;

	/*! \brief The method appends the literal to the SQL-Statement. 
		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilder&	literal			(const VarString& literal);

	/*! \brief The method appends the value of the parametername to the SQL-statement. 
		\n     UnknownPropertyNameException */
	LIBBASARDBASPECT_API SQLStringBuilder&	value			(const PropertyName& rPropertyName);

    /*! \brief The method solves the parameter and append the pattern to the SQL-statement.
		\n     UnknownPropertyNameException */
	LIBBASARDBASPECT_API SQLStringBuilder&	resolve			(const VarString& pattern);
	
    /*! \brief The method returns the value which belongs to parametername. 
		\n     UnknownPropertyNameException */
	LIBBASARDBASPECT_API const VarString	getParamValue	(const PropertyName& rPropertyName) const;
	
    /*! \brief The method inits the SQL-statement.
		\n     no-throw */
	LIBBASARDBASPECT_API void clear();

private:
	/*! \brief pointer to the implemental class SQLStringBuilderImpl*/
	boost::shared_ptr<ISQLStringBuilderImpl> m_pBuilder; 
};


/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class to build SQL-query-statements.

  From this class the programmer must derive his own class.
  He has to overwrite the functions isExecutable() and
  buildSQLString(). Also he has to write the function create() in the following way: 
  "SQLStringBuilder* create() {	return boost::shared_ptr<SQLStringBuilder>(new mySQLBuilder(*this)); }" */
class SQLQueryStringBuilder : public SQLStringBuilder
{
public:
    /*! \brief d'tor */
    LIBBASARDBASPECT_API virtual ~SQLQueryStringBuilder(){};
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */
	LIBBASARDBASPECT_API std::pair<bool, QueryTypeEnum> isQuery() const;
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API bool isPrepareable() const;
};

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class to build prepareable SQL-query-statements.

  From this class the programmer must derive his own class.
  He has to overwrite the functions isExecutable() and
  buildSQLString(). Also he has to write the function create() in the following way: 
  "SQLStringBuilder* create() {	return boost::shared_ptr<SQLStringBuilder>(new mySQLBuilder(*this)); }" */
class SQLPrepareableQueryStringBuilder : public SQLStringBuilder
{
public:
    /*! \brief c'tor */
    SQLPrepareableQueryStringBuilder() : SQLStringBuilder(PREPARED_STRINGBUILDER) {};
    
    /*! \brief d'tor */
    LIBBASARDBASPECT_API virtual ~SQLPrepareableQueryStringBuilder(){};
    
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */
	LIBBASARDBASPECT_API std::pair<bool, QueryTypeEnum> isQuery() const;
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API bool isPrepareable() const;
};

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class to build SQL-no-query-statements. 

  From this class the programmer must derive his own class.
  He has to overwrite the functions isExecutable() and
  buildSQLString(). Also he has to write the function create() in the following way: 
  "SQLStringBuilder* create() { return boost::shared_ptr<SQLStringBuilder>(new mySQLBuilder(*this)); }" */
class SQLWriteStringBuilder : public SQLStringBuilder
{
public:
    /*! \brief d'tor */
    LIBBASARDBASPECT_API virtual ~SQLWriteStringBuilder(){};
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */
	LIBBASARDBASPECT_API std::pair<bool, QueryTypeEnum> isQuery() const;
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API bool isPrepareable() const;
};


/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class to build prepareable SQL-no-query-statements. 

  From this class the programmer must derive his own class.
  He has to overwrite the functions isExecutable() and
  buildSQLString(). Also he has to write the function create() in the following way: 
  "SQLStringBuilder* create() { return boost::shared_ptr<SQLStringBuilder>(new mySQLBuilder(*this)); }" */
class SQLPrepareableWriteStringBuilder : public SQLStringBuilder
{
public:
    /*! \brief c'tor */
    SQLPrepareableWriteStringBuilder() : SQLStringBuilder(PREPARED_STRINGBUILDER) {};
    
    /*! \brief d'tor */
    LIBBASARDBASPECT_API virtual ~SQLPrepareableWriteStringBuilder(){};
    
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */
	LIBBASARDBASPECT_API std::pair<bool, QueryTypeEnum> isQuery() const;
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API bool isPrepareable() const;
};

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A reference class to build SQL - statements.

  This is a final class.
  This is a value class, copying is allowed. The class is generated by the compiler */
class SQLStringBuilderRef
{
friend class AccessMethod; //!< creator friend class

public:
	/*! \brief construct reference object and initialize shared pointer to implementation object to null
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderRef();
	/*! \brief check if shared pointer to implementation class is null \n no-throw */
	LIBBASARDBASPECT_API bool							    isNull() const;
	/*! \brief set the sharedpointer to null.\n no-throw */
	LIBBASARDBASPECT_API void								reset();

	/*! \brief return true, if the statement is a query. Must be overwritten. 
 		\n     UnknownPointerOfReference */
	LIBBASARDBASPECT_API std::pair<bool, QueryTypeEnum>		isQuery() const;
	/*! \brief The method returns true, if the statement is a query. 
 		\n     no-throw */	
	LIBBASARDBASPECT_API bool isPrepareable() const;
	
    /*! \brief get IndexTypeCollection for this string builder
        \n     no-throw */
	LIBBASARDBASPECT_API const IndexTypeCollection& getPreparedParameterTypePositionCollection() const;
	
	/*! \brief build the statement, if the class is executable 
		\n     UnknownPropertyNameException, NullReferenceException */
	LIBBASARDBASPECT_API bool							    build( const AccessorPropertyTable_YIterator& propertyList );
	/*! \brief Return the statement. \n NullReferenceException */
	LIBBASARDBASPECT_API const VarString&					getSQLString() const;
	/*! \brief set default parameters for all sql-statements of this builder  \n NullReferenceException */
	LIBBASARDBASPECT_API void								setParameterList( const basar::cmnutil::ParameterList paramList );
	
	/*! \brief get default parameters for all sql-statements of this builder  \n NullReferenceException */
	LIBBASARDBASPECT_API basar::cmnutil::ParameterList      getParameterList() const;

private: 
	/*! \brief create the pointer of the class SQLStringBuilder. \n no-throw */
	SQLStringBuilderRef( const boost::shared_ptr<SQLStringBuilder> t );
	/*! \brief create the class SQLStringBuilder itself. \n no-throw */
	const boost::shared_ptr<SQLStringBuilder> create() const;
	/*! \brief Check if pointer is a reference. \n NullReferenceException */
	const boost::shared_ptr<SQLStringBuilder>& getImpl() const;

	boost::shared_ptr<SQLStringBuilder> m_pBuilder; //!< pointer to a SQLStringBuilder
};

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  Iterator of the class SQLStringBuilderListRef

	This is a final class. */
class SQLStringBuilderList_Iterator
{
public:
	/*! \brief The method inits the Iterator with the value from the parameter list. 
 		\n     NullReferenceException */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator (boost::shared_ptr<AccessMethod> method, std::list<SQLStringBuilderRef>::iterator it);

	/*! \brief standard constructor. 
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator ();
	
	/*! \brief The method checks if the internal iterator equals rhp. 
 		\n     no-throw */
	LIBBASARDBASPECT_API bool operator == (const SQLStringBuilderList_Iterator& rhp) const;
	/*! \brief The method checks if the internal Iterator isn't equal to rhp. 
 		\n     no-throw */
	LIBBASARDBASPECT_API bool operator != (const SQLStringBuilderList_Iterator& rhp) const;

	/*! \brief The method returns the next iterator. 
 		\n     OutOfRangeIteratorException */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator operator ++ (); 
	/*! \brief The method returns the current iterator and increases it.
 		\n     OutOfRangeIteratorException */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator operator ++ (int); 
	/*! \brief The method returns the current iterator:
 		\n     OutOfRangeIteratorException */
	LIBBASARDBASPECT_API SQLStringBuilderRef operator*();
	/*! \brief The method returns the current iterator:
 		\n     OutOfRangeIteratorException */
    LIBBASARDBASPECT_API SQLStringBuilderRef* operator->();

	/*! \brief The method checks if iterator points to begin() of the inner container
	\n     no-throw */
	LIBBASARDBASPECT_API bool					isBegin			() const;

	/*! \brief The method checks if iterator points to end() of the inner container
	\n     no-throw */
	LIBBASARDBASPECT_API bool					isEnd			() const;

	/*! \brief The method checks if the iterator points to NULL
		\n     no-throw */
	LIBBASARDBASPECT_API bool isNull() const;

	/*! \brief The method sets the iterator points to NULL
		\n     no-throw */
	LIBBASARDBASPECT_API void reset();
private:
	/*! \brief The method checks if the iterator is valid
 		\n     no-throw */
	void checkValid() const;

	std::list<SQLStringBuilderRef>::iterator m_It;	//!< the current iterator
	boost::shared_ptr<AccessMethod> m_Method;		//!< pointer to the access method
};

/*--------------------------------------------------------------------------------------------------*/
/*! \brief  A class which holds a list of SQLStringBuilderRef.

  This is a final class. */
class SQLStringBuilderListRef
{
public:

public:
	/*! \brief The method inits SQLStringbuilderList with the value from the parameter list.
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderListRef(boost::shared_ptr<AccessMethod> Method);
	/*! \brief The method sets the iterator to the start point.
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator	begin	();
	/*! \brief The method sets the iterator to the end point.
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderList_Iterator	end		();
	/*! \brief The method returns the size of the iterator list.
 		\n     no-throw */
	LIBBASARDBASPECT_API SQLStringBuilderListSize size	() const;
	    
private:
	boost::shared_ptr<AccessMethod> m_Method;		//!< pointer to the access method
};

/*--------------------------------------------------------------------------------------------------*/
} // aspect
} // db
} // basar

/*--------------------------------------------------------------------------------------------------*/
#endif
